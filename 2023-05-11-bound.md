------------------------------------------------------
title: Bound: Split into Something like a Free Monad
summary: Explaining a take on the bound library that uses something like a free monad
tags: haskell
draft: false
------------------------------------------------------

Recently my friend [Jonas Carpay](https://jonascarpay.com/) has been teaching
me about the Haskell package [`bound`](https://hackage.haskell.org/package/bound),
and the fundamental problem it is trying to solve.  `bound` gives a good solution
for defining a lambda calculus in Haskell, specifically with how to differentiate
between bound and free variables.

While playing around with the ideas from `bound`, I found a neat way of defining
a datatype for a lambda calculus using something like a free monad.

This post explains a little background for `bound`, and then shows my own
definition using the free-monad-like structure.

## Lambda Calculus

Most Haskellers will be familiar with lambda calculus.  Even if you've never
studied it, you will recognize it just from being familiar with Haskell.

An example lambda calculus expression might look like the following:

```
\x -> \y -> a (x y)
```

Lambda calculus has variables, function application, and lambda functions.  All
things that you'll be familiar with from Haskell.

If you wanted to write a data type in Haskell to represent a lambda calculus
expression, what might it look like?  You might start with something like this:

```haskell
data ExpTooSimp
  = ExpTooSimpVar String
    -- ^ This refers to a variable, like @x@.
  | ExpTooSimpApp ExpTooSimp ExpTooSimp
    -- ^ This refers to a function application, like @f x@.
  | ExpTooSimpLam String ExpTooSimp
    -- ^ This refers to a lambda function, like @\x -> _@.
```

So our above example lambda calculus expression might look like the following
in Haskell:

```haskell
ExpTooSimpLam "x"
  ( ExpTooSimpLam "y"
      ( ExpTooSimpApp
          (ExpTooSimpVar "a")
          (ExpTooSimpApp (ExpTooSimpVar "x") (ExpTooSimpVar "y"))
      )
  )
```

One generalization we can make is turning the `String` into a parameter:

```haskell
data ExpSimp a
  = ExpSimpVar a
    -- ^ This refers to a variable, like @x@.
  | ExpSimpApp (ExpSimp a) (ExpSimp a)
    -- ^ This refers to a function application, like @f x@.
  | ExpSimpLam a (ExpSimp a)
    -- ^ This refers to a lambda function, like @\x -> _@.
```

Then, instead of having `ExpTooSimp`, we have `ExpSimp String`.

This datatype is certainly easy to understand, but it leaves a little to be
desired.

## Bound vs Free Variables

One thing that the above Haskell datatype doesn't address is our desire to
differentiate between bound and free variables.

For instance, in the expression:

```
\x -> \y -> a (x y)
```

the `x` and `y` are bound variables, while the `a` is a free variable.

How would we change our datatype to take this bound-vs-free information into
account?

The article [Bound](https://www.schoolofhaskell.com/user/edwardk/bound) by
Edward Kmett explains a bunch of different ways to express this in Haskell.
The article works towards explaining a specific technique, and why it is
better than most other techniques.  The specific technique is wrapped up
in the [`bound`](https://hackage.haskell.org/package/bound) Haskell package.

The general idea from `bound` is take our simple expression datatype:

```haskell
data ExpSimp a
  = ExpSimpVar a
    -- ^ This refers to a variable, like @x@.
  | ExpSimpApp (ExpSimp a) (ExpSimp a)
    -- ^ This refers to a function application, like @f x@.
  | ExpSimpLam a (ExpSimp a)
    -- ^ This refers to a lambda function, like @\x -> _@.
```

and rewrite it like this[^1]:

```haskell
data Exp a
  = ExpVar a
    -- ^ This refers to a variable, like @x@.
  | ExpApp (Exp a) (Exp a)
    -- ^ This refers to a function application, like @f x@.
  | ExpLam (Exp (Maybe a))
    -- ^ This refers to a lambda function, like @\x -> _@.
```

The `ExpVar` and `ExpApp` cases haven't changed, but the `ExpLam` case needs
some explaining.

First off, in the new `ExpLam`, where has the variable name gone?  Why isn't this
something like `ExpLam a (Exp a)`?

The insight is that in `ExpLam (Exp (Maybe a))`, we're recursing on `Exp`, but
on every recursion, we add a new layer of `Maybe` to `a`.  It will help to look
at a few examples.

Using `Exp String`, here's a top-level free variable without any lambdas involved.

| lambda calculus | haskell |
|-----|-----|
| `a` | `ExpVar "a"` |

This should be straight-forward.

How about a simple lambda expression, with a free variable, and with a bound
variable:

|   | lambda calculus | haskell |
|-----|-----|-----|
| bound variable | `\x -> x` | `ExpLam (ExpVar Nothing)` |
| free variable | `\x -> a` | `ExpLam (ExpVar (Just "a"))` |

You can see that here, within one layer of `ExpLam`, `ExpVar` now takes a type
of `Maybe String`.  `Just` refers to a free variable, while `Nothing` refers to
the closest bound variable.

This is pretty neat.  We now have a way to differentiate free and bound
variables.  Bound variables don't even need to carry around a variable name
(once a variable is bound, it doesn't really matter what its name is)!

What does this look like with more layers of lambdas?  Here are a few more examples:

|   | lambda calculus | haskell |
|-----|-----|-----|
| bound to inner lambda | `\x -> \y -> y` | `ExpLam (ExpLam (ExpVar Nothing))` |
| bound to outer lambda | `\x -> \y -> x` | `ExpLam (ExpLam (ExpVar (Just Nothing)))` |
| free variable | `\x -> \y -> a` | `ExpLam (ExpLam (ExpVar (Just (Just "a"))))` |

You can see here that within two layers of lambdas, `ExpVar` now takes a type
of `Maybe (Maybe String)`.  So with each layer of lambda, we add a new layer of
`Maybe`.

With two layers of lambda (and two corresponding layers of `Maybe`), you can
see that `Nothing` refers to the closest binding lambda, `Just Nothing` refers
to the next closest binding lambda, and `Just (Just v)` refers to a free
variable.

While this is certainly clever, why do we prefer `Exp` over `ExpSimp`?

## Monad and Foldable for Exp


## Conclusion


## Footnotes

[^1]: The actual `bound` package is significantly more complicated than
    this `ExpSimp` type, but `ExpSimp` is a reasonable first-order
    approximation of the technique in `bound`.
